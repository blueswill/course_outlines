* 操作系统引论
** 操作系统作用 (扩充硬件功能, 控制管理/调度作业, 使用接口)
** 发展过程
   |------------------+---------------------------------------------------------|
   | 类型             | 说明                                                    |
   |------------------+---------------------------------------------------------|
   | 单道批处理       | 批: 一次处理的相关磁带                                  |
   |                  | 联机批处理: 主机处理I/O                                 |
   |                  | 脱机批处理: 卫星机处理I/O                               |
   |                  | 卫星机: 卡片<->磁带                                     |
   |                  | 主机: 磁带<->磁带                                       |
   |                  | 优点: 自动更替作业, 吞吐率提高                          |
   |                  | 缺点: 缺乏调度, 资源不能充分利用                        |
   |------------------+---------------------------------------------------------|
   | 多道批处理       | 引入调度程序, 吞吐量大, 资源利用率高                    |
   |                  | 交互性差, 周转时间长                                    |
   |------------------+---------------------------------------------------------|
   | 分时系统         | 时间片, 轮转调度, 交互性好, 主机共享, 用户独立          |
   |------------------+---------------------------------------------------------|
   | 实时系统         | 响应时间短, 系统可靠                                    |
   |------------------+---------------------------------------------------------|
   | 多处理机操作系统 | 吞吐量高(并行), 提高可靠性                              |
   |                  | 紧密耦合(并行系统, 统一OS)/松散耦合(分布式系统, 不同OS) |
   |                  | 非对称式多重处理/对称式多重处理                         |
   |------------------+---------------------------------------------------------|
   | 网络操作系统     |                                                         |
   | 分布式操作系统   |                                                         |
   |------------------+---------------------------------------------------------|

** 操作系统特征 (并发/共享/虚拟/异步)
** 提供的服务及功能
   进程控制/文件系统管理/IO操作/通信/配置/差错管理
   存储管理/设备管理/处理机管理/文件管理/用户接口
** 微内核的设计方式以及基本功能

** 硬件保护
   双模式/IO保护(设备保护)/存储保护(基地址寄存器/界限寄存器/访问方式保护)/CPU保护(定时中断)

* 进程
** 定义
   *进程*: 一定独立功能的程序在一个数据集合上的一次动态执行的过程.
   *线程*: 进程中执行代码流, 是处理机的调度单位
** 执行特征
   | 顺序执行 | 顺序性/封闭性/可再现性 |
   | 并发执行 | 间断性/不封闭/不可再现 |
   操作系统的任务: 保持并发程序的封闭性/可再现性
   *封闭性*: 独占全部资源, 运行状态和其他进程无关
   动态性(生命周期/存储空间)/并发性/独立性(分配资源的基本单元)/异步性(并发导致的不确定)/结构化(PCB和其他段数据)

** 组成 (代码段/数据段/堆栈/进程控制块(PCB))
   进程和程序的区别(动态/生命周期/组成/对应关系)

** 进程状态(三状态模型/六状态模型)
   引起状态转换的原因

** 进程控制块(PCB)(内容及组织方式)
   进程描述信息/状态信息/调度信息/控制信息(内存位置/同步通信/资源)
** 进程控制
   |----------------+------------------------------------------------------|
   | 行为           | 描述                                                 |
   |----------------+------------------------------------------------------|
   | 进程创建       | 进程图(描述子进程和父进程的关系)                     |
   |                | 引起创建的事件(用户登录/请求服务/应用请求)           |
   |                | 步骤: 申请PCB/分配资源/初始化PCB/插入就绪队列        |
   |----------------+------------------------------------------------------|
   | 进程终止       | 引起终止的事件(异常/干预)                            |
   |                | 过程: 终止子进程/回收资源/通知调度/移除PCB(收集信息) |
   |----------------+------------------------------------------------------|
   | 进程阻塞       |                                                      |
   |----------------+------------------------------------------------------|
   | 进程激活与挂起 |                                                      |
   |----------------+------------------------------------------------------|

** 进程同步
   进程的关系:
   - 互斥 排他性资源引起的竞争
   - 同步 多个进程之间存在时序关系
   
   进程的制约关系: 相互无感知/间接感知/直接感知

   同步准则:
   |----------+------|
   | 名称     | 含义 |
   |----------+------|
   | 空闲则入 |      |
   |----------+------|
   | 忙则等待 |      |
   |----------+------|
   | 有限等待 |      |
   |----------+------|
   | 让权等待 |      |
   |----------+------|

*** 同步方式
**** 面包店算法
**** 硬件同步指令(CAS)
     - TestAndSet
     - Swap
**** 信号量
     #+BEGIN_SRC C
     struct {
             int count; //number of shared resources
             struct process *queue; //block queue
     };
     #+END_SRC
***** 用二进制信号量模拟信号量
      #+BEGIN_SRC C
      int S1 = 1;
      int S2 = 0;
      int C = 10; //number of resources

      void wait() {
              wait(S1);
              --C;
              if (C < 0) {
                      signal(S1);
                      wait(S2);
              }
              signal(S1);
      }

      void signal() {
              wait(S1);
              ++C;
              if (C <= 0) {
                      signal(S2);
              }
              else {
                      signal(S1);
              }
      }
      #+END_SRC
***** 读写锁
      #+BEGIN_SRC C
      //信号量
      int wrt = 1;
      int readcnt = 0;
      int rlock = 1;

      //write
      wait(wrt);
      //progress
      signal(wrt);

      //read
      wait(rlock);
      if (readcnt == 1)
              wait(wrt);
      signal(rlock)
      //progress
      wait(rlock)
      --readcnt;
      if (readcnt == 0)
              signal(wrt);
      signal(rlock);
      #+END_SRC
***** 哲学家进餐问题
      - 仅当两只筷子都能用的时候才拿起筷子
      - 奇数人先拿左边, 偶数人先拿右边(防止循环等待) 

*** 进程通信
    - 低级通信
      只传递状态和整数值
    - 高级通信
      - 共享存储器系统
        OS 分配存储器, 进程负责数据结构的分配和同步处理
      - 共享存储区 (关键字标识存储区)
      - 消息传递系统
        - 直接通信
          send(p1, m), recv(p1, m)
          直接提供对方的标识符
        - 间接通信 共享数据结构作中转(信箱 私有/公有/共享)
      - 管道通信系统 (互斥/同步/确定对方存在)
**** 线程 减少创建/终止/切换开销, 提高效率/吞吐量/并发性
     - CPU调度单位 (不是资源分配单位)
     - 共享进程资源
     - 轻型实体(切换开销小)
     - 进程和线程的区别(资源/状态变化/开销/共享存储区/通信)
     - 用户级线程和系统级线程的区别
       - 运行在用户态/核心态(TLB)
       - 用户态进行调度/核心态进行调度
       - 并行性
* 调度
** 类型
 - 高级调度 (作业(通过 *SPOOLING* 技术保存在 *输入井* 中) -> 内存调度)
 - 中级调度 (进程 <-> 外存调度)
 - 低级调度 (CPU调度)
** 准则
 - 用户角度 (周转时间/响应时间/(开始/完成)截止时间/优先级准则)
 - 系统角度 (吞吐量高/CPU利用率高(PC一般不考虑)/资源的均衡利用)
** 调度算法
 - 先来先服务(FCFS) 唤醒后进入就绪队列
   I/O 繁忙的作业频繁进入就绪队列, 一直等待
 - 短作业优先(SJF) 减少平均周转时间
 - 最短剩余时间优先(SRF)
 - 最高响应比优先(HRRN)(非抢占式)
   \[ 响应比 = \frac{等待时间 + 要求执行时间}{要求执行时间} \]
 - 优先权调度
   - 抢占方式
     完全不可抢占(用户态不可抢占)/内核不可抢占/内核部分可抢占(抢占点)/完全可抢占(内核完全可抢占)
   - 优先级的确定
     - 静态优先级 (进程类型(系统/用户)/资源需求/用户要求)
     - 动态优先级 (就绪队列/时间片后)
 - 时间片轮转调度算法(RR)(公平/响应时间)
 - 多级反馈队列调度算法(RR with multiple feedback)
   - 多个不同优先级的就绪队列
   - 鼓励I/O, 阻塞变为就绪的进入队列1的尾部或者头部, 甚至抢占CPU
   - 防止进程饿死
* 死锁
  - 原因 (竞争资源(不可剥夺资源/临时性资源)/顺序不当)
  - 条件
    互斥/请求和保持/不可剥夺/环路等待
  - 处理方法
    - 预防死锁 破坏条件
      - 预先静态分配(没有请求) (降低利用率/并发)
      - 剥夺已获得的资源 (代价/吞吐率)
      - 有序资源使用(环路等待)
    - 避免死锁 资源分配中防止进入不安全状态(银行家算法)
    - 检测死锁 允许进入死锁 检测后采取措施(资源分配图)
    - 解除死锁 采取措施
  - 安全状态 (按照某种顺序分配资源, 任何时刻总有进程能够得到所有资源)
    - 银行家算法
      #+BEGIN_SRC C++
      //related structures
      int available[K]; //ready for allocate
      int max_need[N][K];
      int allocate[N][K];
      int need[N][K];
      //sastify need[i] + allocate[i] == max_need[i]

      //init
      int work[K] = available;
      bool finish[N]{false};

      int search() {
              for (int i = 0; i < N; ++i) {
                      if (!finish[i] && need[i] <= work)
                              return i;
              }
              return -1;
      }

      while ((i = search()) != -1) {
              work += allocate[i];
              finish[i] = true;
              print(i);
      }
      #+END_SRC
      
      #+BEGIN_SRC C++
      // request resource
      if (request > need[i]) refuse();
      if (request > available[i]) wait();
      available -= request;
      need[i] -= request;
      allocation[i] += request;
      if (in_secure_state()) accept_request();
      else wait();
      #+END_SRC
  - 检测解除死锁 (保存资源请求分配信息)
    - 死锁检测算法(资源分配图/代码算法(和上述类似))
    - 解除死锁(终止进程/剥夺资源)
* 存储管理 (内存存储 位置/存储/寻址方式)
** 重定位 (逻辑地址(相对地址)->物理地址(绝对地址))
   - 静态重定位 (编译/加载重定位)
   - 动态重定位 (执行)
** 程序装入方式
   - 绝对装入
   - 可重定位装入(连续/不可移动) 静态重定位
   - 动态运行时装入 (部分装入/执行时重定位) 动态重定位
     分散存储/支持运行时产生的地址引用/硬件支持
** 链接方式
   - 静态链接(冗余)
   - 装入时动态链接(共享/修改更新方便)
   - 运行时动态链接(部分装入/局部代码修改/适应环境)
** 内存分配 (单一连续分配/固定分区分配/动态分区分配)
   - 单一连续分配(将用户区的所有空间都给进程)
   - 固定分区分配(静态划分)
   - 空闲分区分配算法(空闲分区表/链表/区位图)
     - 首次适应算法
     - 循环首次适应算法(从上次分配的位置开始寻找)
     - 最佳适应
     - 最坏适应
     - 快速适应算法
   - 伙伴系统
   - 可重定位分区分配时采用紧凑(compact)操作
   - 对换(旧进程(阻塞) -> 外存) 整个进程的地址空间
** 分页存储 (离散存储程序, 没有外碎片, 程序全部装入)
   - 数据结构
     进程页表/物理页面表(空闲页面链表/位示图)/请求表(PCB或者独立)
   - 页面大小选择(优缺点)
   - 页表过大
     - 分散存储 (多级页表)
** 分段存储
   - 数据结构
     进程段表/系统段表(+空闲段表)
   - 和分页存储的区别
     物理单位 大小不固定 二维结构 段大小比较大 更易共享
** 段页式存储
   - 数据结构
     段表 -> 页表(每个段一个)
** 虚拟存储器 (解决一次性和驻留性)
   定义: 引入了缺页(段)管理(调入调出机制)的扩充后的存储器系统
   - 实现方式 (硬件: 地址变换机构/段(页), MMU)
     - 请求分页
     - 请求分段
     - 段页式
   - 内存分配策略 (最小块数)
     - 固定分配局部置换
     - 可变分配全局置换
     - 可变分配局部置换
     - 物理块分配策略(页框数分配)
     - 页面调入策略(装入时/请求调页)
   - 页面置换算法(降低缺页率, 防止抖动, 锁定)
     - 最佳置换
     - 先进先出(FIFO)
     - 最近最久未使用(LRU)
     - Clock 置换
     - 改进的Clock(A=0M=0 -> A=0M=1)
     - 页面缓冲算法(空闲页面链表/已修改页面链表)
       有机会从链表中得到最近淘汰的页面, 降低缺页率
   - 工作集策略
   - 抖动预防 (使用工作集/挂起进程/局部置换)
   - 请求分段 (共享段表 计数/存取控制)
* 设备管理 (I/O 设备)
** 设计目标
   - 提供统一界面 (逻辑设备名/设备独立性)
   - 提高并行性和效率
   - 正确安全
** IO 管理 (缓冲区/分配/处理/虚拟设备)
   - 缓冲类型 (单缓冲/双缓冲/循环缓冲/缓冲池(三队列 收容/提取))
   - IO 软件 (*设备无关*->逻辑设备, 统一命名->逻辑名, 错误处理, 缓冲, 设备分配释放, IO控制方式)
     - 用户级软件
     - 设备独立的操作系统软件
       - 逻辑->物理(LUT)
       - 缓冲区管理/独立设备分配
       - 保护设备/差错管理
       - 逻辑数据块/统一接口
     - 设备驱动程序
     - 设备中断处理程序
   - 设计模式 (抽象/封装/分层)
   - 设备分配数据结构
     - 设备 -> 设备分配表(DCT)
     - 系统 -> 系统设备表(SDT)
     - 控制器 -> 控制器控制表(COCT)
     - 通道 -> 通道控制表(CHCT)
   - SPOOLING 技术
     输入输出井(外存) 输入输出缓冲区(内存) 输入输出进程 守护进程(daemon) 井管理程序
     - 特点 (高速/共享(模拟独占)/虚拟(独占设备虚拟为多个逻辑设备))
** 磁盘调度
   *磁臂黏着问题*: 一个或多个进程频繁访问一个磁道上的数据, 造成磁臂长期停留在一个位置.
 - 磁盘调度算法
   - 先来先服务(FCFS)
   - 最短寻道优先(SSTF)
   - 扫描算法(SCAN)
   - 循环扫描算法(CSCAN)
   - N-Step-SCAN/F-SCAN
 - 磁盘耗时
   \[ 读出数据的时间 = 磁头定位时间 + 平均旋转等待时间 + 读出磁盘扇区数据的时间 \]
   \[ 磁头定位时间 = 移动一个磁道的时间 \times 移动的总磁道数 \]
   \[ 平均旋转等待时间 = \frac{转一圈的时间}{2} \]
   \[ 读出一个扇区数据的时间 = \frac{转一圈的时间}{一圈的扇区数} \]
   \[ 读出扇区数据的时间 = 读出一个扇区数据的时间 \times 扇区数 \]
 - 磁盘高速缓存 (大小固定/所有未利用内存空间)
   - 交付方式
     复制到用户区/传递指针
   - 置换算法 (同页表置换)
   - 数据一致性问题 (日志系统)
   - 提高性能的方法 (提前读->高速缓冲区/延迟写/优化磁盘块分布/虚拟盘(操作对用户透明))
* 文件管理 (访问控制/权限管理/性能/差错)
  - 文件系统结构模型
    目录管理 -> 文件系统 -> 磁盘存储映射
    - 文件内容
      - 有结构文件(数据项->记录)
      - 无结构文件(字符流)
    - 文件类型和操作
    - 文件逻辑结构 *用户的观点* (索引/顺序/索引顺序/直接(HASH))
    - 物理结构(单位: 簇) *最大文件长度计算*
      - 连续分配
      - 链接分配(隐式链接/显式链接(FAT文件分配表))
      - 索引分配(单级索引/多级索引/混合)
*** 目录管理(文件检索的特殊文件/元数据文件)
    - 数据结构
      - FCB -> {目录, i-node}
        - i-node -> {磁盘, 内存}
    - 目录结构(单级/多级)
      - 主要因素 检索时间/重名/结构
    - 目录查询(线性(缓存)/B树)
*** 空闲空间管理
    - 空闲表法(分配算法同内存分配算法(连续分配为主))
    - 空闲链表
    - 位示图
    - 成组链接(串成一条链表)
      空闲盘块栈单指链表第一个盘块
      插入删除都从第一个盘块栈顶开始
*** 文件共享 (硬链接/软链接)
    - 语义
      UNIX语义: 读在写完之后
      会晤语义: 写在关闭文件之后
      分布式: 不允许改/原子事务
*** 文件保护 (物理修改/非法访问)
    - 访问控制列表(ACL)(用户/组/其他)
*** 文件系统实现(对象:文件/目录/磁盘存储空间)
    - 用户接口
    - 数据结构算法(逻辑->物理)